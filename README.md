# Лабораторная работа №3

## Как использовать
 - Запуск тестов: `pytest tests/ -v`

## Математические функции

### Факториал

```
print(factorial(5))           # 120

# Или рекурсивная версия
print(factorial_recursive(5)) # 120
```

### Числа Фибоначчи

```
print(fibo(10))           # 55

# Или рекурсивная версия
print(fibo_recursive(10)) # 55
```

## Алгоритмы сортировки

### 1. Bubble Sort (Сортировка пузырьком)
- **Сложность**: O(n²)
- **Память**: O(1)
```
a = [64, 34, 12, 25]
sorted_a = bubble_sort(a)
print(sorted_arr)  #[64, 34, 25, 12]
```

### 2. Heap Sort (Сортировка кучей)
- **Сложность**: O(n log n)
- **Память**: O(1)

```
a = [64, 34, 12, 25]
sorted_a = heap_sort(a)
print(sorted_a)  #[12, 25, 34, 64]
```

### 3. Quick Sort (Быстрая сортировка)
- **Сложность**: O(n log n) средний, O(n²) худший (когда неудачно pivot выбран)
- **Память**: O(log n)

```
a = [64, 34, 12, 25]
sorted_a = quick_sort(a, 0, len(a) - 1)
print(sorted_a)  #[12, 25, 34, 64]
```

### 4. Counting Sort (Сортировка подсчетом)
- **Сложность**: O(n + k), где k - диапазон тех данных, что мы сортируем
- **Память**: O(k)

```
a = [4, 2, 2, 8, 3, 3, 1]
sorted_a = counting_sort(a)
print(sorted_a)  #[1, 2, 2, 3, 3, 4, 8]
```

### 5. Radix Sort (Поразрядная сортировка)
- **Сложность**: O(nk), где k - максимальное количество разрядов в тех данных, что мы сортируем
- **Память**: O(n + k)

```
a = [170, 45, 75, 90, 802, 24, 2, 66]
sorted_a = radix_sort(arr.copy())
print(sorted_a)  # [2, 24, 45, 66, 75, 90, 170, 802]
```

### 6. Bucket Sort (Блочная сортировка)
- **Сложность**: O(n + k)
- **Память**: O(n + k)
- **Применение**: Для чисел с плавающей точкой

```

a = [0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
sorted_a = bucket_sort(a.copy())
print(sorted_a)  #[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
```

## Очередь (Queue)

### Реализация на связном списке

```
# Создание очереди
queue = Queue()

# Добавление элементов
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)

# Просмотр первого элемента
print(queue.front.data)  #10

# Удаление элементов
print(queue.dequeue())   #10
print(queue.dequeue())   #20

# Проверка размера
print(len(queue))        #1
print(queue.is_empty())  #False
```

### Основные операции:
- `enqueue(i)` - добавить элемент в конец
- `dequeue()` - удалить и вернуть первый элемент
- `front` - получить первый элемент (без удаления)
- `is_empty()` - проверить, пуста ли очередь
- `__len__()` - получить размер очереди

## Генераторы тестовых данных для сортировок

### 1. Случайные массивы

```
# Целые числа (возможны дубликаты)
a1 = rand_int_array(10, 1, 100, seed=15)

# Уникальные целые числа
a2 = rand_int_array(10, 1, 100, distinct=True, seed=15)

# Числа с плавающей точкой
a3 = rand_float_array(10, 0.0, 1.0, seed=15)
```

### 2. Специальные массивы

```
# Почти отсортированный
a4 = nearly_sorted(10, swaps=3, seed=15)

# С дубликатми
a5 = many_duplicates(10, k_unique=3, seed=15)

# Обратно отсортированный
a6 = reverse_sorted(10)
```